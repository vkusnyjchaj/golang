# Интерфейсы

Интерфейсный тип представляет собой набор сигнатур методов:
```
type Abser interface {
	Abs() float64
}
```

Значение интерфейсного типа может хранить любое значение которое реализует необходимые методы.

В Go не нужно явно указывать реализацию интерфейса. Достаточно реализовать необохдимые методы:
```
type I interface {
	M()
}

type T struct {
	S string
}

// This method means type T implements the interface I,
// but we don't need to explicitly declare that it does so.
func (t T) M() {
	fmt.Println(t.S)
}

func main() {
	var i I = T{"hello"}
	i.M()
}
```

Под капотом значения интерфейсов можно воспринимать как кортеж `(value, type)`.
Вызов метода на значении интерфейса выполняет метод с тем же именем на его базовом типе.

В Go интерфейс может хранить nil в качестве значения. Интерфейс != nil, если у него есть тип, даже если значение nil:
```
func (p *Person) M() {
    if p == nil {
        fmt.Println("Я nil, но метод работает")
    }
}
```

В Go это нормальная практика - писать методы, которые умеют работать с nil:
```
var i Interface = nil        // i == nil 
var p *Person = nil
var i Interface = p         // i != nil 
```

Интерфейс равен nil ТОЛЬКО если нет типа и нет значения. При этом вызов метода на таком интерфейсе вызовет ошибку.

Интерфейс который не содержит методов известен как *пустой интерфейс*. Такой интерфейс может хранить значения любого типа.

Пустые интерфейсы используются кодом который обрабатывает значения неизвестного типа.

Утверждение типа
```
var i interface{} = "hello"
s := i.(string)
```
предоставляет доступ к значению интерфейса.
Оно определяет что интерфейсное значение i содержит конкретный тип T и присваивает базовое значение T переменной t.
Если тип не соответствует - вызовется `panic`.

Для проверки используется `t, ok := i.(T)`:
- если тип верен, вернется значение и true
- если тип не верен, вернется нулевое значение предполагаемого типа и false
