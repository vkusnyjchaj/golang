# Сборка мусора в Go

Сборщик мусор в Go является одновременным (Concurrent) - сборка осуществляется параллельно выполнению потоков приложения (мутаторов). Для избежания утечек памяти при изменении ссылок во время процесса сборки мусора используется барьер записи, когда все потоки приложения читают определенный флаг в памяти и если он установлен, то запрещается доступ к памяти на чтение и потоки останавливаются при первой попытке чтения памяти после блокировки. Сама сборка осуществляется с использование подхода "трех цветов" и обхода графа ссылкок на объекты, где цвеа:
- объект исследован
- объект не исследован
- объект ожидающий исследования (узнали про объект, но не прошлись по всем ссылкам от него)

Также в рамках подхода "трех цветов" есть правило что не бывает ссылок из исследованного объекта в не исследованный - между ними всегда объект, ожидающий исследования.

Фазы сборки мусора:
1) Завершить предыдущую сборку мусора если выполняется (Sweep termination)
2) Фаза сканирования глобальных переменных, стека, разметка объектов методом "трех цветов" (Mark). Перед этим включается барьер на запись в память.
3) Фаза завешения разметка (Mark termination)
4) Фаза очистки (Sweep). Отключается барьер на запись в память. Очистка происходит уже после восстановления работы приложения и происходит параллельно его работе.

Когда запускается сборка мусора в Go:
- Превышение лимита кучи (heap) заданного в переменной GOGC (если GOGC < 100% сборка будет чаще, иначе - реже, со значением off сборка мусора будет отключена)
- Через 2 минуты отсутствия сборки мусора, за что отвечает sysmon
- Вручную, с помощью метода runtime.GC() (если сборка мусора уже запущена, то по окончании она будет запущена еще раз)

Для избежания частых сборок мусора применяется баласт (ballast) - выделяется заранее большая область памяти, чтобы расширить GOGC и сборка запускалась сразу относительно этой
большой области. Важно что например в linux память не будет выделена заранее физически, будет только расширено адресное пространство пока туда не будет совершена первая запись (lazy allocation).

Есть два размера области памяти:
- RSS (Resident Set Size) память которая используется программой для хранения данных
- VMS (Vitrual Memory Size) память которая зарезервирована для использования (swap, аллоцирована, но не используется сейчас)

В Go существует ситуация, называемая спиралью смерти (death spiral), возникающая в случае если размер RSS чуть меньше чем размер аллоцированной памяти при которой будет произведена следующая сборка мусора. Для избежания этой ситуации есть переменная GOMEMLIMIT, устанавливающая искусственное ограничение на потребление сборщиком CPU

Источники:
[Секрет сборщика мусора в Go раскрыт](https://www.youtube.com/watch?v=p5OAXkbiiCY)